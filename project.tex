\documentclass[12pt]{article}
\usepackage[
    backend=biber,
    style=alphabetic,
    style=numeric,
    citestyle=numeric,
]{biblatex}
\usepackage[margin=5em]{geometry}
\usepackage[utf8]{inputenc}
\usepackage{listings}
\usepackage{mathpartir}
\usepackage{stmaryrd}
\usepackage{syntax}
\usepackage{textcomp}
\usepackage{amsmath}

\addbibresource{bibliography.bib}

\lstset{
    frame=single,
    gobble=4,
    language=Python,
}

\setlength\parindent{0em}
\setlength\parskip{1em}

\newcommand\mono\texttt
\newcommand{\metavar}[1]{\textlangle#1\textrangle}
\newcommand{\dblbr}[1]{\llbracket#1\rrbracket}
\renewcommand{\AA}{\mathcal{A}}
\newcommand{\BB}{\mathcal{B}}
\newcommand{\LL}{\mathcal{L}}

\title{
    Python Comprehensions in While:\\
    Initial Version
}
\author{
    Hendrik Werner s4549775
    \and Constantin Blach s4329872
    \and Jona Heidsick s0710512
}

\begin{document}

\maketitle

\begin{abstract}
\noindent % so there is no random space in the beginning of the abstract
In this document we extend the language While with list comprehensions inspired by Python. We explore the syntactical and semantic changes and additions needed to achieve this. Finally we analyze the extensions we made using a case study of a While program.
\end{abstract}

\section{Introduction}
Comprehensions are extremely useful for dealing with container types and functional constructs in imperative languages. Python is an example of an imperative language that uses comprehensions, which can be used as more idiomatic versions of \mono{filter} and \mono{map}. They are not limited to this use case though.

By combining and nesting list comprehensions, it is possible to implement complicated calculations with minimal syntax and maximum elegance. Take the following Python program as an example:

\begin{lstlisting}
    def cartesian_product(a, b):
        return [(x, y) for x in a for y in b]
\end{lstlisting}

It defines the Cartesian product in terms of list comprehensions. We want to be able to express this in the language While as well.

We want to use Natural Semantics (NS) to describe list comprehensions in While, because as opposed to Structural Operational Semantics (SOS) it offers a higher level overview over the semantics. SOS is concerned with the individual steps of a computation, while NS describes the overall results \cite{wiley}. The high level overview is a better fit to describe list comprehensions. Python is a great example of that. Python 2 and Python 3 both offer list comprehensions with the same semantics, but with a different implementation behind the scenes. This is not really relevant to the semantics though:

\begin{minipage}[t]{.48\linewidth}
    \begin{lstlisting}[gobble=8, title=Python 2]
        >>> [x*2 for x in [1, 2, 3]]
        [2, 4, 6]
    \end{lstlisting}
\end{minipage}
\,
\begin{minipage}[t]{.48\linewidth}
    \begin{lstlisting}[gobble=8, title=Python 3]
        >>> [x*2 for x in [1, 2, 3]]
        [2, 4, 6]
    \end{lstlisting}
\end{minipage}

The individual steps are different for Python 2 and Python 3, but the overall result is the same.

Our goal is to eventually show the execution of the following While program:

\begin{lstlisting}
    x := 1:2:3:[];
    y := [a * 2 for a in x]
\end{lstlisting}

Such that given the state $s_{\perp, \perp}$, executing the program will result in the state $s_{1:2:3:[], 1*2:2*2:3*2:[]}$.

\section{First Principles}

\subsection{Syntactical extensions}

The syntax we need is given here in Backus-Naur form (BNF). The semantics with applications book uses something very similar to BNF, but it is not quite BNF \cite[section 1.2]{wiley}. We repeat the definitions given in the book here, using BNF.

\begin{itemize}
    \item \metavar{n} will range over numerals, \textbf{Num},
    \item \metavar{x} will range over variables, \textbf{Var},
    \item \metavar{a} will range over arithmetic expressions, \textbf{Aexp},
    \item \metavar{b} will range over boolean expressions, \textbf{Bexp},
    \item \metavar{l} will range over list expressions, \textbf{Lexp}, and
    \item \metavar{S} will range over statements, \textbf{Stm}.
\end{itemize}

\begin{grammar}
    <a> ::= <n>
    \alt <x>
    \alt <a1> "+" <a2>
    \alt <a1> "*" <a2>
    \alt <a1> "-" <a2>

    <b> ::= "true"
    \alt "false"
    \alt <a1> "=" <a2>
    \alt $\lnot$<b>
    \alt <b1> $\land$ <b2>

    <l> ::= "[]"
    \alt <n>":"<l>
    \alt "["<a> "for" <x> "in" <l>"]"

    <S> ::= <x> ":=" <a>
    \alt "skip"
    \alt <S1> ";" <S2>
    \alt "if" <b> "then" <S1> "else" <S2>
    \alt "while" <b> "do" <S>
    \alt <x> ":=" <l>
\end{grammar}

\subsection{Semantical extensions} % I don't know why "semantical" is marked as a typo, I googled it to be sure, it's correct.

\begin{mathpar}
    \inferrule*[left={$[\text{ass}_a]$}]{}{<x:=a, s> \rightarrow s[x \mapsto \AA \dblbr{a}s]}\\
    \inferrule*[left={$[\text{ass}_l]$}]{}{<x:=l, s> \rightarrow s[x \mapsto \LL \dblbr{l}]}\\
    \inferrule*[left={$[\text{skip}]$}]{}{<\text{skip}, s> \rightarrow s}\\
    \inferrule*[left={$[\text{comp}]$}]
        {<S1, s> \rightarrow s', <S2, s'> \rightarrow s''}
        {<S1; S2, s> \rightarrow s''} \\
    \inferrule*[left={$[\text{if}^{tt}]$}, right={if $\BB \dblbr{b}s = \mathbf{tt}$}]
        {<S1, s> \rightarrow s'}
        {<\text{if } b\ \text{then } S1\ \text{else } S2, s> \rightarrow s'}\\
    \inferrule*[left={$[\text{if}^{ff}]$}, right={if $\BB \dblbr{b}s = \mathbf{ff}$}]
        {<S2, s> \rightarrow s'}
        {<\text{if } b\ \text{then } S1\ \text{else } S2, s> \rightarrow s'}\\
    \inferrule*[left={$[\text{while}^{tt}]$}, right={if $\BB \dblbr{b}s = \mathbf{tt}$}]
        {<S, s> \rightarrow s', <\text{while } b\ \text{do } S, s'> \rightarrow s''}
        {<\text{while } b\ \text{do } S, s> \rightarrow s''} \\
    \inferrule*[left={$[\text{while}^{ff}$]}, right={if $\BB \dblbr{b}s = \mathbf{ff}$}]
        {}
        {<\text{while } b\ \text{do } S, s> \rightarrow s} \\
\end{mathpar}

\section{Application}

\subsection{List assignment}
$s_x$ means that variable $a$ has the value $x$ in state $s$.

\begin{mathpar}
    \inferrule*[right={$[\text{ass}_l]$}]{}{<a := [], s_\perp> \rightarrow s_{[]}}
\end{mathpar}

\printbibliography

\end{document}
