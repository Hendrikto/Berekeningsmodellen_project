% TODO:
% * definition ENV
% * redefine \AA and \BB
% * include changes in the explanation text
% * change other rules to include ENV

\documentclass[12pt]{article}
\usepackage{amsmath}
\usepackage{amsfonts}
\usepackage[
    backend=biber,
    style=alphabetic,
    style=numeric,
    citestyle=numeric,
]{biblatex}
\usepackage[margin=5em]{geometry}
\usepackage[utf8]{inputenc}
\usepackage{listings}
\usepackage{mathpartir}
\usepackage{stmaryrd}
\usepackage{syntax}
\usepackage{textcomp}

\addbibresource{bibliography.bib}

\lstset{
    frame=single,
    gobble=4,
    language=Python,
}

\setlength\parindent{0em}
\setlength\parskip{1em}

\newcommand\mono\texttt
\newcommand{\metavar}[1]{\textlangle#1\textrangle}
\newcommand{\dblbr}[1]{\llbracket#1\rrbracket}
\renewcommand{\AA}{\mathcal{A}}
\newcommand{\BB}{\mathcal{B}}
\newcommand{\LL}{\mathcal{L}}
\newcommand{\NN}{\mathcal{N}}
\newcommand{\Var}{\mathbf{Var}}
\newcommand{\Avar}{\mathbf{Avar}}
\newcommand{\Lvar}{\mathbf{Lvar}}
\newcommand{\Aexp}{\mathbf{Aexp}}
\newcommand{\Bexp}{\mathbf{Bexp}}
\newcommand{\Lexp}{\mathbf{Lexp}}
\newcommand{\Astate}{\mathbf{Astate}}
\newcommand{\Lstate}{\mathbf{Lstate}}
\newcommand{\Llit}{\mathbf{Llit}}
\newcommand{\Lcomp}{\mathbf{Lcomp}}

\title{
    Python Comprehensions in While:\\
    Second Version
}
\author{
    Hendrik Werner s4549775
    \and Constantin Blach s4329872
    \and Jona Heidsick s0710512
}

\begin{document}

\maketitle

\begin{abstract}
\noindent % so there is no random space in the beginning of the abstract
In this document we extend the language While with list comprehensions inspired by Python. We explore the syntactical and semantic changes and additions needed to achieve this. Finally we analyze the extensions we made using a case study of a While program.
\end{abstract}

\tableofcontents

\section{Introduction}
Comprehensions are extremely useful for dealing with container types and functional constructs in imperative languages. Python is an example of an imperative language that uses comprehensions, which can be used as more idiomatic versions of \mono{filter} and \mono{map}. They are not limited to this use case though.

By combining and nesting list comprehensions, it is possible to implement complicated calculations with minimal syntax and maximum elegance. Take the following Python program as an example:

\begin{lstlisting}
    def cartesian_product(a, b):
        return [(x, y) for x in a for y in b]
\end{lstlisting}

It defines the Cartesian product in terms of list comprehensions. We want to be able to express this in the language While as well.

We want to use Natural Semantics (NS) to describe list comprehensions in While, because as opposed to Structural Operational Semantics (SOS) it offers a higher level overview over the semantics. SOS is concerned with the individual steps of a computation, while NS describes the overall results \cite{wiley}. The high level overview is a better fit to describe list comprehensions. Python is a great example of that. Python 2 and Python 3 both offer list comprehensions with the same semantics, but with a different implementation behind the scenes. This is not really relevant to the semantics though:

\begin{lstlisting}[title=Python 2/3]
    >>> [x*2 for x in [1, 2, 3]]
    [2, 4, 6]
\end{lstlisting}

The individual steps are different for Python 2 and Python 3, but the overall result is the same.

Our goal is to eventually show the execution of the following While program:

\begin{lstlisting}
    x := 1:2:3:[];
    y := [a * 2 for a in x]
\end{lstlisting}

Such that given the state $s_{\perp, \perp}$, executing the program will result in the state $s_{1:2:3:[], 2:4:6:[]}$.

\section{First Principles}

\subsection{Syntactical extensions}

The syntax we need is given here in Backus-Naur form (BNF). The semantics with applications book uses something very similar to BNF, but it is not quite BNF \cite[section 1.2]{wiley}. We repeat the definitions given in the book here, using BNF.

\subsubsection{Metavariables}

\begin{itemize}
    \item \metavar{n} will range over numerals, \textbf{Num},
    \item \metavar{x} will range over arithmetic variables, $\Avar$,
    \item \metavar{y} will range over list variables, $\Lvar$,
    \item \metavar{a} will range over arithmetic expressions, \textbf{Aexp},
    \item \metavar{b} will range over boolean expressions, $\Bexp$,
    \item \metavar{l} will range over list expressions, $\Lexp = \Llit \cup \Lcomp$,
    \item \metavar{ll} will range over list literals, $\Llit$,
    \item \metavar{lc} will range over list comprehensions, $\Lcomp$, and
    \item \metavar{S} will range over statements, \textbf{Stm}.
\end{itemize}

\subsubsection{Syntax}

\begin{grammar}
    <a> ::= <n>
    \alt <x>
    \alt <a1> "+" <a2>
    \alt <a1> "*" <a2>
    \alt <a1> "-" <a2>

    <b> ::= "true"
    \alt "false"
    \alt <a1> "=" <a2>
    \alt $\lnot$<b>
    \alt <b1> $\land$ <b2>

    <l> ::= <ll>
    \alt <lc>

    <ll> ::= "[]"
    \alt <a>":"<ll>

    <lc> ::= "["<a> for <x> "in" <l>"]"
    \alt "["<a> "for" <x> "in" <y>"]"

    <S> ::= <x> ":=" <a>
    \alt "skip"
    \alt <S1> ";" <S2>
    \alt "if" <b> "then" <S1> "else" <S2>
    \alt "while" <b> "do" <S>
    \alt <y> ":=" <l>
\end{grammar}

\subsubsection{Differences}

In addition to the variables that are used by Nielson and Nielson \cite{wiley}, we split the While variables into arithmetic variables and list variables. This allows us to prevent strange construction like

\begin{lstlisting}
    x := 4;
    y := 1:2:[z * 2 for z in x]
\end{lstlisting}

on a semantical level, so we don't have to deal with them "at run time". This is also convenient for the programmer, as a potential While compiler/interpreter could catch these errors early, instead of bailing out when trying to run the program.

\mono{x} is an arithmetic variable, which is not allowed to the the position it does in the above code. This position needs to be filled by either a list \metavar{l} or a list variable \metavar{y}.

Additionally the definition of list variable \mono{y} begins with a list literal \metavar{ll}, and then continues with a list comprehension \metavar{lc}. The syntax we chose forbids this, as you have to choose between both versions when defining a list \metavar{l}.

\subsection{Semantic extensions} % I don't know why "semantical" is marked as a typo, I googled it to be sure, it's correct.

\subsubsection{Semantic Functions}

Nielson and Nielson define the state function as being of type $\Var \rightarrow \mathbb{Z}$, so we need to redefine it. We have two types of variables: $\Avar$ and $\Lvar$, so we also have two state functions.

\begin{itemize}
    \item $Astate: \Avar \rightarrow \mathbb{Z}$

    This is just the function $State$ from Nielson and Nielson \cite{wiley}, but renamed to fit to our case with split list variables and arithmetic variables.
    \item $Lstate: \Lvar \rightarrow \mathbb{N} \rightarrow \mathbb{Z}$

    This state function is used to hold the state of lists, which we represent as functions from the natural numbers to integers, which is a good fit to represent sequences of values, so for example:

    After executing the While program \mono{x := 1:2:[]}, $Lstate(x) = f[0 \mapsto 1, 1 \mapsto 2]$, so that $f(0) = 1, f(1) = 2, f(x > 1) = \perp$
\end{itemize}

The intersection of domains of $Astate$ and $Lstate$ is empty, such that $Astate(x) \neq \perp \rightarrow Lstate(x) = \perp \land Lstate(x) \neq \perp \rightarrow Astate(x) = \perp$. This is because we want to use every variable name for \textbf{either} an arithmetic variable, \textbf{or} a list variable, so that we never end up with a list variable with the same name as an arithmetic variable.

We also introduced a new function $\LL$, which translates between list expressions and the function representation we chose that defines the list.

$$\LL: \Llit \rightarrow \mathbb{N} \rightarrow \mathbb{Z}$$

$\begin{aligned}
    f(x) &= \perp & \LL(h:t, n) &= \LL(t, n + 1)[n \mapsto \NN \dblbr{h}]\\
    \LL(l) &= \LL(l, 0) & \LL([], n) &= f\\
\end{aligned}$

The semantics of $\AA$ and $\BB$ are identical to the version in the book, only $\mathbf{State}$ has been renamed to $\Astate$:

$$\AA: \Aexp \rightarrow (\Astate \rightarrow \mathbb{Z})$$

$$\BB: \Bexp \rightarrow (\Astate \rightarrow \mathbb{T})$$

\subsubsection{Semantics}

\begin{mathpar}
    \inferrule*[left={$[\text{ass}_a]$}]
        {}
        {ENV \vdash <\text{x := a}, s> \rightarrow ENV \vdash s[x \mapsto \AA \dblbr{a}s]}\\
    \inferrule*[left={$[\text{ass}_{lc}]$}]
        {ENV \vdash <l, s> \rightarrow ENV' \vdash s}
        {ENV \vdash <\text{y := l}, s> \rightarrow [] \vdash s[y \mapsto \LL \dblbr{ENV'}]}\\
    \inferrule*[left={$[\text{ass}_{ll}]$}]
        {}
        {ENV \vdash <\text{y := l}, s> \rightarrow ENV \vdash s[y \mapsto \LL \dblbr{l}]}\\
    \inferrule*[left={$[\text{skip}]$}]
        {}
        {ENV \vdash <\text{skip}, s> \rightarrow ENV \vdash s}\\
    \inferrule*[left={$[\text{comp}]$}]
        {ENV \vdash <S1, s> \rightarrow ENV' \vdash s', ENV' \vdash <S2, s'> \rightarrow ENV'' \vdash s''}
        {ENV \vdash <S1; S2, s> \rightarrow ENV'' \vdash s''} \\
    \inferrule*[left={$[\text{if}^{tt}]$}, right={if $\BB \dblbr{b}s = \mathbf{tt}$}]
        {ENV \vdash <S1, s> \rightarrow ENV' \vdash s'}
        {ENV \vdash <\text{if b then S1 else S2}, s> \rightarrow ENV' \vdash s'}\\
    \inferrule*[left={$[\text{if}^{ff}]$}, right={if $\BB \dblbr{b}s = \mathbf{ff}$}]
        {ENV \vdash <S2, s> \rightarrow ENV' \vdash s'}
        {ENV \vdash <\text{if b then S1 else S2}, s> \rightarrow ENV' \vdash s'}\\
    \inferrule*[left={$[\text{while}^{tt}]$}, right={if $\BB \dblbr{b}s = \mathbf{tt}$}]
        {ENV \vdash <S, s> \rightarrow ENV' \vdash s', ENV' \vdash <\text{while b do S}, s'> \rightarrow ENV'' \vdash s''}
        {ENV \vdash <\text{while b do S}, s> \rightarrow ENV'' \vdash s''}\\
    \inferrule*[left={$[\text{while}^{ff}$]}, right={if $\BB \dblbr{b}s = \mathbf{ff}$}]
        {}
        {ENV \vdash <\text{while b so S}, s> \rightarrow ENV \vdash s}\\
    \inferrule*[left={$[\text{lcomp}^{start}]$}]
        {\AA \dblbr{a}s[x \mapsto h]:[] \vdash <\text{[a for x in t]}, s> \rightarrow ENV \vdash s}
        {[] \vdash <\text{[a for x in h:t]}, s> \rightarrow ENV \vdash s}\\
    \inferrule*[left={$[\text{lcomp}^{mid}]$}]
        {head: \AA \dblbr{a}s[x \mapsto h]:[] \vdash <\text{[a for x in t]}, s> \rightarrow ENV \vdash s}
        {head:[] \vdash <\text{[a for x in h:t]}, s> \rightarrow ENV \vdash s}\\
    \inferrule*[left={$[\text{lcomp}^{end}]$}]
        {}
        {ENV \vdash <\text{[a for x in []]}, s> \rightarrow ENV \vdash s}
\end{mathpar}

\subsubsection{Differences}

The assignment rule was split into arithmetic assignment, as defined by Nielson and Nielson \cite{wiley}, and list assignment.

Additionally, we added rules to perform list comprehensions in While.
During the list comprehension, we use an ENV, where we build a list corresponding to the rule.
At the end, when the editing is done, the list will be copied from the ENV and used further on.
We use three different rules for this, as we have three different cases (start, mid and end).
The $[lcomp^{start}]$ rule looks as follows:

\begin{mathpar}
    \inferrule*[left={$[\text{lcomp}^{start}]$}]
        {\AA \dblbr{a}s[x \mapsto h]:[] \vdash <\text{[a for x in t]}, s> \rightarrow ENV \vdash s}
        {[] \vdash <\text{[a for x in h:t]}, s> \rightarrow ENV \vdash s}\end{mathpar}

Before we apply this rule, our ENV initially contains an empty list.
For this we use the $\Aexp$ a on the first element (the head or h) in the list we want to edit and add the outcome ($\AA \dblbr{a}s[x \mapsto h]$) to our ENV list as the first element.
We then need to remove the head element of our h:t list, as we now already considered this element.

After this first step, we need to use the $[lcomp^{mid}]$ rule as long as the h:t list still contains any elements:
\begin{mathpar}
    \inferrule*[left={$[\text{lcomp}^{mid}]$}]
        {head:\AA \dblbr{a}s[x \mapsto h]:[] \vdash <\text{[a for x in t]}, s> \rightarrow ENV \vdash s}
        {head:[] \vdash <\text{[a for x in h:t]}, s> \rightarrow ENV \vdash s}
\end{mathpar}

This rule almost works the same as the first rule, but now we already have a non-empty list in our ENV on the left side.
When applying this rule, we again take the head element from the h:t list and apply the $\Aexp$ a on it.
We then receive an outcome of the form $\AA \dblbr{a}s[x \mapsto h]$, which we add as the new element at the end of the ENV list.
Also we need to delete this h element from our initial list h:t.
We use this rule as long as h:t matches, meaning that the list is not empty.

When the list matches \mono{[]}, which means it is empty, we have to use our last rule $[lcomp^{end}]$, which looks like the following:

\begin{mathpar}
    \inferrule*[left={$[\text{lcomp}^{end}]$}]
        {}
        {ENV \vdash <\text{[a for x in []]}, s> \rightarrow ENV \vdash s}
\end{mathpar}

This rule finalizes the building of the new list in ENV and "saves" it in the ENV on the right side, which is then used further on in the whole computation.

\section{Application}

\subsection{List assignment}
$s_x$ means that variable $a$ has the value $x$ in state $s$.

\begin{mathpar}
    \inferrule*[right={$[\text{ass}_l]$}]{}{<a := [], s_\perp> \rightarrow s_{[]}}
\end{mathpar}

\subsection{List comprehension with list literal}

\begin{mathpar}
    \inferrule*[right={$[\text{lcomp}^{start}]$}]
        {\inferrule*[right={$[\text{lcomp}^{mid}]$}]
            {\inferrule*[right={$[\text{lcomp}^{end}]$}]
                {}
                {2:3:[] \vdash <\text{[x + 1 for x in []]}, s> \rightarrow 2:3:[] \vdash s}
            }
            {2:[] \vdash <\text{[x + 1 for x in 2:[]]}, s> \rightarrow 2:3:[] \vdash s}
        }
        {[] \vdash <\text{[x + 1 for x in 1:2:[]]}, s> \rightarrow 2:3:[] \vdash s}
\end{mathpar}

\printbibliography

\end{document}
