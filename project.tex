\documentclass[12pt]{article}
\usepackage{amsmath}
\usepackage{amsfonts}
\usepackage[
    backend=biber,
    style=alphabetic,
    style=numeric,
    citestyle=numeric,
]{biblatex}
\usepackage[margin=5em]{geometry}
\usepackage[utf8]{inputenc}
\usepackage{listings}
\usepackage{mathpartir}
\usepackage{stmaryrd}
\usepackage{syntax}
\usepackage{textcomp}

\addbibresource{bibliography.bib}

\lstset{
    frame=single,
    gobble=4,
    language=Python,
}

\setlength\parindent{0em}
\setlength\parskip{1em}

\newcommand\mono\texttt
\newcommand{\metavar}[1]{\textlangle#1\textrangle}
\newcommand{\dblbr}[1]{\llbracket#1\rrbracket}
\renewcommand{\AA}{\mathcal{A}}
\newcommand{\BB}{\mathcal{B}}
\newcommand{\LL}{\mathcal{L}}
\newcommand{\NN}{\mathcal{N}}
\newcommand{\Var}{\mathbf{Var}}
\newcommand{\Avar}{\mathbf{Avar}}
\newcommand{\Lvar}{\mathbf{Lvar}}
\newcommand{\Lexp}{\mathbf{Lexp}}

\title{
    Python Comprehensions in While:\\
    Second Version
}
\author{
    Hendrik Werner s4549775
    \and Constantin Blach s4329872
    \and Jona Heidsick s0710512
}

\begin{document}

\maketitle

\begin{abstract}
\noindent % so there is no random space in the beginning of the abstract
In this document we extend the language While with list comprehensions inspired by Python. We explore the syntactical and semantic changes and additions needed to achieve this. Finally we analyze the extensions we made using a case study of a While program.
\end{abstract}

\tableofcontents

\section{Introduction}
Comprehensions are extremely useful for dealing with container types and functional constructs in imperative languages. Python is an example of an imperative language that uses comprehensions, which can be used as more idiomatic versions of \mono{filter} and \mono{map}. They are not limited to this use case though.

By combining and nesting list comprehensions, it is possible to implement complicated calculations with minimal syntax and maximum elegance. Take the following Python program as an example:

\begin{lstlisting}
    def cartesian_product(a, b):
        return [(x, y) for x in a for y in b]
\end{lstlisting}

It defines the Cartesian product in terms of list comprehensions. We want to be able to express this in the language While as well.

We want to use Natural Semantics (NS) to describe list comprehensions in While, because as opposed to Structural Operational Semantics (SOS) it offers a higher level overview over the semantics. SOS is concerned with the individual steps of a computation, while NS describes the overall results \cite{wiley}. The high level overview is a better fit to describe list comprehensions. Python is a great example of that. Python 2 and Python 3 both offer list comprehensions with the same semantics, but with a different implementation behind the scenes. This is not really relevant to the semantics though:

\begin{lstlisting}[title=Python 2/3]
    >>> [x*2 for x in [1, 2, 3]]
    [2, 4, 6]
\end{lstlisting}

The individual steps are different for Python 2 and Python 3, but the overall result is the same.

Our goal is to eventually show the execution of the following While program:

\begin{lstlisting}
    x := 1:2:3:[];
    y := [a * 2 for a in x]
\end{lstlisting}

Such that given the state $s_{\perp, \perp}$, executing the program will result in the state $s_{1:2:3:[], 1*2:2*2:3*2:[]}$.

\section{First Principles}

\subsection{Syntactical extensions}

The syntax we need is given here in Backus-Naur form (BNF). The semantics with applications book uses something very similar to BNF, but it is not quite BNF \cite[section 1.2]{wiley}. We repeat the definitions given in the book here, using BNF.

\subsubsection{Metavariables}

\begin{itemize}
    \item \metavar{n} will range over numerals, \textbf{Num},
    \item \metavar{x} will range over arithmetic variables, $\Avar$,
    \item \metavar{y} will range over list variables, $\Lvar$,
    \item \metavar{a} will range over arithmetic expressions, \textbf{Aexp},
    \item \metavar{b} will range over boolean expressions, \textbf{Bexp},
    \item \metavar{l} will range over list expressions, $\Lexp$, and
    \item \metavar{S} will range over statements, \textbf{Stm}.
\end{itemize}

\subsubsection{Syntax}

\begin{grammar}
    <a> ::= <n>
    \alt <x>
    \alt <a1> "+" <a2>
    \alt <a1> "*" <a2>
    \alt <a1> "-" <a2>

    <b> ::= "true"
    \alt "false"
    \alt <a1> "=" <a2>
    \alt $\lnot$<b>
    \alt <b1> $\land$ <b2>

    <l> ::= <ll>
    \alt <lc>

    <ll> ::= "[]"
    \alt <a>":"<ll>

    <lc> ::= "["<a> for <x> "in" <l>"]"
    \alt "["<a> "for" <x> "in" <y>"]"

    <S> ::= <x> ":=" <a>
    \alt "skip"
    \alt <S1> ";" <S2>
    \alt "if" <b> "then" <S1> "else" <S2>
    \alt "while" <b> "do" <S>
    \alt <y> ":=" <l>
\end{grammar}

\subsubsection{Differences}

In addition to the variables that are used by Nielson and Nielson \cite{wiley}, we split the While variables into arithmetic variables and list variables. This allows us to prevent strange construction like

\begin{lstlisting}
    x := 4;
    y := 1:2:[z * 2 for z in x]
\end{lstlisting}

on a semantical level, so we don't have to deal with them "at run time". This is also convenient for the programmer, as a potential While compiler/interpreter could catch these errors early, instead of bailing out when trying to run the program.

\mono{x} is an arithmetic variable, which is not allowed to the the position it does in the above code. This position needs to be filled by either a list \metavar{l} or a list variable \metavar{y}.

Additionally the definition of list variable \mono{y} begins with a list literal \metavar{ll}, and then continues with a list comprehension \metavar{lc}. The syntax we chose forbids this, as you have to choose between both versions when defining a list \metavar{l}.

\subsection{Semantical extensions} % I don't know why "semantical" is marked as a typo, I googled it to be sure, it's correct.

\subsubsection{Sematics}

\begin{mathpar}
    \inferrule*[left={$[\text{ass}_a]$}]{}{<x:=a, s> \rightarrow s[x \mapsto \AA \dblbr{a}s]}\\
    \inferrule*[left={$[\text{ass}_l]$}]{}{<y:=l, s> \rightarrow s[y \mapsto \LL \dblbr{l}]}\\
    \inferrule*[left={$[\text{skip}]$}]{}{<\text{skip}, s> \rightarrow s}\\
    \inferrule*[left={$[\text{comp}]$}]
        {<S1, s> \rightarrow s', <S2, s'> \rightarrow s''}
        {<S1; S2, s> \rightarrow s''} \\
    \inferrule*[left={$[\text{if}^{tt}]$}, right={if $\BB \dblbr{b}s = \mathbf{tt}$}]
        {<S1, s> \rightarrow s'}
        {<\text{if } b\ \text{then } S1\ \text{else } S2, s> \rightarrow s'}\\
    \inferrule*[left={$[\text{if}^{ff}]$}, right={if $\BB \dblbr{b}s = \mathbf{ff}$}]
        {<S2, s> \rightarrow s'}
        {<\text{if } b\ \text{then } S1\ \text{else } S2, s> \rightarrow s'}\\
    \inferrule*[left={$[\text{while}^{tt}]$}, right={if $\BB \dblbr{b}s = \mathbf{tt}$}]
        {<S, s> \rightarrow s', <\text{while } b\ \text{do } S, s'> \rightarrow s''}
        {<\text{while } b\ \text{do } S, s> \rightarrow s''} \\
    \inferrule*[left={$[\text{while}^{ff}$]}, right={if $\BB \dblbr{b}s = \mathbf{ff}$}]
        {}
        {<\text{while } b\ \text{do } S, s> \rightarrow s} \\
    \inferrule*[left={$[\text{lcomp}^{[]}]$}]
        {}
        {<\text{[a for x in l]}, s> \rightarrow ?}
\end{mathpar}

Nielson and Nielson define the state function as being of type $\Var \rightarrow \mathbb{Z}$, so we need to redefine it. We have two types of variables: $\Avar$ and $\Lexp$, so we also have two state functions.

\begin{itemize}
    \item $Astate: \Avar \rightarrow \mathbb{Z}$

    This is just the function $State$ from Nielson and Nielson \cite{wiley}, but renamed to fit to our case with split list variables and arithmetic variables.
    \item $Lstate: \Lvar \rightarrow \mathbb{N} \rightarrow \mathbb{Z}$

    This state function is used to hold the state of lists, which we represent as functions from the natural numbers to integers, which is a good fit to represent sequences of values, so for example:

    After executing the While program \mono{x := 1:2:[]}, $Lstate(x) = f[0 \mapsto 1, 1 \mapsto 2]$, so that $f(0) = 1, f(1) = 2, f(x > 1) = \perp$
\end{itemize}

The intersection of domains of $Astate$ and $Lstate$ is empty, such that $Astate(x) \neq \perp \rightarrow Lstate(x) = \perp \land Lstate(x) \neq \perp \rightarrow Astate(x) = \perp$. This is because we want to use every variable name for \textbf{either} an arithmetic variable, \textbf{or} a list variable, so that we never end up with a list variable with the same name as an arithmetic variable.

We also introduced a new function $\LL$, which translates between list expressions and the function representation we chose that defines the list.

$\begin{aligned}
    f(x) &= \perp & \LL(h:t, n) &= \LL(t, n + 1)[n \mapsto \NN \dblbr{h}]\\
    \LL(l) &= \LL(l, 0) & \LL([], n) &= f\\
\end{aligned}$

\subsubsection{Differences}

The assignment rule was split into arithmetic assignment, as defined by Nielson and Nielson \cite{wiley}, and list assignment.

\section{Application}

\subsection{List assignment}
$s_x$ means that variable $a$ has the value $x$ in state $s$.

\begin{mathpar}
    \inferrule*[right={$[\text{ass}_l]$}]{}{<a := [], s_\perp> \rightarrow s_{[]}}
\end{mathpar}

\printbibliography

\end{document}
